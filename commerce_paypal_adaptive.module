<?php

/**
 * @file
 * Implements PayPal Adaptive Payments in Drupal Commerce checkout.
 */

/**
 * Implements hook_commerce_payment_method_info().
 */
function commerce_paypal_adaptive_commerce_payment_method_info() {
  $payment_methods = array();

  $payment_methods['paypal_adaptive'] = array(
    'base' => 'commerce_paypal_adaptive',
    'title' => t('PayPal Adaptive'),
    'short_title' => t('PayPal'),
    'description' => t('PayPal Website Payments Standard'),
    'terminal' => FALSE,
    'offsite' => TRUE,
    'offsite_autoredirect' => TRUE,
  );

  return $payment_methods;
}

/**
 * Implements hook_entity_info_alter().
 */
function commerce_paypal_adaptive_entity_info_alter(&$entity_info) {
  // Alter the commerce_payment_transaction entity info to make it fieldable
  $entity_info['commerce_payment_transaction']['fieldable'] = TRUE;
}

/**
 * Implements hook_menu().
 */
function commerce_paypal_adaptive_menu() {

  //dd(__FUNCTION__, date("h:i:s" ,time()));
  $items = array();

  // Define an additional IPN path that is specific to our payment method /
  // instance.
  $items['commerce_paypal/paypal-adaptive/ipn'] = array(
    'page callback' => 'commerce_paypal_adaptive_process_ipn',
    'page arguments' => array(),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Returns the default settings for the PayPal Adaptive payment method.
 */
function commerce_paypal_adaptive_default_settings() {
//dd(__FUNCTION__, date("h:i:s" ,time()));
  $default_currency = commerce_default_currency();
  return array(
    'application_id' => '',
    'api_username' => '',
    'api_caller_email' => '',
    'api_password' => '',
    'api_signature' => '',
    'currency_code' => in_array($default_currency, array_keys(commerce_paypal_adaptive_currencies())) ? $default_currency : 'USD',
    'allow_supported_currencies' => FALSE,
    'language' => 'US',
    'server' => 'sandbox',
    'ipn_logging' => 'notification',
    'ipn_create_billing_profile' => FALSE,
    'show_payment_instructions' => FALSE,
/*
    'pay_chain' => array(
      'primary_receiver' => array(
        'primary_receiver_percentage' => '100.00',
        'primary_receiver_email' => '',
      ),
    ),
*/
  );
}

/**
 * Payment method callback: settings form.
 */
function commerce_paypal_adaptive_settings_form($settings = array()) {
  //dd(__FUNCTION__, date("h:i:s" ,time()));
  $form = array();

  // Merge default settings into the stored settings array.
  $settings = (array) $settings + commerce_paypal_adaptive_default_settings();

  $form['api_caller_email'] = array(
    '#type' => 'textfield',
    '#title' => t('PayPal API caller email'),
    '#description' => t('Your PayPal email account as a API caller'),
    '#default_value' => $settings['api_caller_email'],
    '#required' => TRUE,
  );
  $form['application_id'] = array(
    '#type' => 'textfield',
    '#title' => t('PayPal application id'),
    '#description' => t('Your PayPal application\'s identification, issued by PayPal.'),
    '#default_value' => $settings['application_id'],
    '#required' => TRUE,
  );
  $form['api_username'] = array(
    '#type' => 'textfield',
    '#title' => t('PayPal API username'),
    '#description' => t('Your PayPal API username.'),
    '#default_value' => $settings['api_username'],
    '#required' => TRUE,
  );
  $form['api_password'] = array(
    '#type' => 'textfield',
    '#title' => t('PayPal API password'),
    '#description' => t('Your PayPal API password.'),
    '#default_value' => $settings['api_password'],
    '#required' => TRUE,
  );
  $form['api_signature'] = array(
    '#type' => 'textfield',
    '#title' => t('PayPal API signature'),
    '#description' => t('Your PayPal API signature.'),
    '#default_value' => $settings['api_signature'],
    '#required' => TRUE,
  );
  $form['currency_code'] = array(
    '#type' => 'select',
    '#title' => t('Default currency'),
    '#description' => t('Transactions in other currencies will be converted to this currency, so multi-currency sites must be configured to use appropriate conversion rates.'),
    '#options' => commerce_paypal_adaptive_currencies(),
    '#default_value' => $settings['currency_code'],
  );
  $form['allow_supported_currencies'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow transactions to use any currency in the options list above.'),
    '#description' => t('Transactions in unsupported currencies will still be converted into the default currency.'),
    '#default_value' => $settings['allow_supported_currencies'],
  );
  $form['language'] = array(
    '#type' => 'select',
    '#title' => t('PayPal login page language / locale'),
    '#options' => commerce_paypal_adaptive_languages(),
    '#default_value' => $settings['language'],
  );
  $form['server'] = array(
    '#type' => 'radios',
    '#title' => t('PayPal server'),
    '#options' => array(
      'sandbox' => ('Sandbox - use for testing, requires a PayPal Sandbox account'),
      'live' => ('Live - use for processing real transactions'),
    ),
    '#default_value' => $settings['server'],
  );
  $form['ipn_logging'] = array(
    '#type' => 'radios',
    '#title' => t('IPN logging'),
    '#options' => array(
      'notification' => t('Log notifications during IPN validation and processing.'),
      'full_ipn' => t('Log notifications with the full IPN during validation and processing (used for debugging).'),
    ),
    '#default_value' => $settings['ipn_logging'],
  );
  $form['show_payment_instructions'] = array(
    '#type' => 'checkbox',
    '#title' => t('Show a message on the checkout form when PayPal Adaptive is selected telling the customer to "Continue with checkout to complete payment via PayPal."'),
    '#default_value' => $settings['show_payment_instructions'],
  );
/*
  // Paychain definition
  $form['pay_chain'] = array(
    '#type' => 'fieldset',
    '#title' => t('Payment Receiver'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
  );
*/
/*
  $form['pay_chain']['primary_receiver'] = array(
    '#type' => 'fieldset',
    '#title' => t('Receiver'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
    '#description' => t('The primary receiver is the primary party to receive payment and initially receives 100% of the payment.'),
  );
  $form['pay_chain']['primary_receiver']['primary_receiver_email'] = array(
    '#type' => 'textfield',
    '#title' => t('Receiver\'s PayPal e-mail address'),
    '#description' => t('The e-mail address of the receiver\'s PayPal account.'),
    '#default_value' => $settings['pay_chain']['primary_receiver']['primary_receiver_email'],
    '#required' => TRUE,
  );
*/
/*
  // If token is installed, this paychain is token-enabled
  if (module_exists('token')) {
    $form['pay_chain']['tokens'] = array(
      '#theme' => 'token_tree',
      '#token_types' => array('commerce-order'),
    );
  }
*/
  return $form;
}

/**
 * Payment method callback: adds a message to the submission form if enabled in
 * the payment method settings.
 */
function commerce_paypal_adaptive_submit_form($payment_method, $pane_values, $checkout_pane, $order) {
  //dd(__FUNCTION__, date("h:i:s" ,time()));
  $form = array();

  if (!empty($payment_method['settings']['show_payment_instructions'])) {
    $form['paypal_adaptive_information'] = array(
      '#markup' => '<span class="commerce-paypal-adaptive-info">' . t('(Continue with checkout to complete payment via PayPal.)') . '</span>',
    );
  }

  return $form;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function commerce_paypal_adaptive_form_commerce_checkout_form_alter(&$form, &$form_state) {
  //dd(__FUNCTION__, date("h:i:s" ,time()));
  // If this checkout form contains the payment method radios...
  if (!empty($form['commerce_payment']['payment_method']['#options'])) {
    // Loop over its options array looking for a PayPal Adaptive option.
    foreach ($form['commerce_payment']['payment_method']['#options'] as $key => &$value) {
      list($method_id, $rule_name) = explode('|', $key);

      // If we find PayPal Adaptive...
      if ($method_id == 'paypal_adaptive') {
        // Prepare the replacement radio button text with icons.
        $icons = commerce_paypal_icons();
        $value = t('!logo PayPal - pay securely without sharing your financial information', array('!logo' => $icons['paypal']));
        $value .= '<div class="commerce-paypal-icons"><span class="label">' . t('Includes:') . '</span>' . implode(' ', $icons) . '</div>';

        // Add the CSS.
        $form['commerce_payment']['payment_method']['#attached']['css'][] = drupal_get_path('module', 'commerce_paypal_adaptive') . '/theme/commerce_paypal_adaptive.theme.css';

        break;
      }
    }
  }
}

/**
 * [If you are the sender and the caller, the approval is implicit
 * @param  [type] $form           [description]
 * @param  [type] $form_state     [description]
 * @param  [type] $order          [description]
 * @param  [type] $payment_method [description]
 * @return [type]                 [description]
 */
function commerce_paypal_adaptive_immplicitly_approved($order, $payment_method) {
 // Get product id from first order line item.
 // the following code is copied from clevername, https://drupal.org/node/2050565
  $orders = commerce_order_load_multiple(array(), array('status' => 'pending'), TRUE);

  foreach($orders as $order) {
    foreach ($order->commerce_line_items['und'] as $line) {
      $line_item = commerce_line_item_load($line['line_item_id']);
      $product_id = $line_item->commerce_product['und'][0]['product_id'];
    }
  //Load first product from order line item and fetch author uid
    $product_item = commerce_product_load($product_id);
    $product_uid = $product_item->uid;
  }
  if ($product_uid == 1)
    return TRUE;
  else
    return FALSE;
}

function commerce_paypal_adaptive_get_products_with_owner($thisOrder) {
    // the following code is copied from clevername, https://drupal.org/node/2050565
    $orders = commerce_order_load_multiple(array(), array('status' => 'pending'), TRUE);

	//$product_uid;
    //foreach($orders as $order)
    //{
        //foreach ($order->commerce_line_items['und'] as $line)
		//{
        //    $line_item = commerce_line_item_load($line['line_item_id']);
        //    $product_id = $line_item->commerce_product['und'][0]['product_id'];
        //}
      
	    //Load first product from order line item and fetch author uid
        //$product_item = commerce_product_load($product_id);
        //$product_uid = $product_item->uid;
		
		//dpm($product_item);
		//dd("lala");
		
		//$product_wrapper = entity_metadata_wrapper('commerce_product', $product_id);
		//$product_nodes = $product_wrapper->field_product_node->value();
		//$product_node = node_load($product_nodes);
		//$product_uid = $product_node->uid;
	//}
	
    $product_ids = array();
	$product_items = array();
	$product_uids = array();
    foreach (entity_metadata_wrapper('commerce_order', $thisOrder)->commerce_line_items as $delta => $line_item_wrapper)
    {
        if (in_array($line_item_wrapper->type->value(), commerce_product_line_item_types()))
	    {
          $product_ids[] = $line_item_wrapper->commerce_product->raw();
		  $product_items[end($product_ids)] = array();
		  $product_items[end($product_ids)]['product'] = commerce_product_load(end($product_ids));
		  $product_items[end($product_ids)]['price'] = $line_item_wrapper->value()->commerce_unit_price['und'][0];
		  $product_items[end($product_ids)]['quantity'] = (int)$line_item_wrapper->value()->quantity;
		  $product_uids[] = end($product_items)['product']->uid;
        }
    }
	//$product_id = end($product_ids);
	//$product_item = commerce_product_load($product_id);
	//$product_uid = $product_item->uid;
	//dpm($product_ids);
	//dpm($product_items);
	
    return $product_items;
}
/**
 * Method to return list of receivers of funds.
 */
function commerce_paypal_adaptive_get_receivers($order)
{
    $payment_method = commerce_payment_method_instance_load('paypal_adaptive|commerce_payment_paypal_adaptive');
    $settings = $payment_method['settings'];
    $wrapper = entity_metadata_wrapper('commerce_order', $order);
    $currency_code = $settings['currency_code'];
    $order_currency_code = $wrapper->commerce_order_total->currency_code->value();
    if (!empty($settings['allow_supported_currencies']) && in_array($order_currency_code, array_keys(commerce_paypal_currencies('paypal_adaptive'))))
    {
        $currency_code = $order_currency_code;
    }
    $product_items = commerce_paypal_adaptive_get_products_with_owner($order);
    //$product_user = user_load($product_uid[0]);
    
    //dpm($product_items);
    
    $receivers = array();
    $receivers_counter = 0;
    $receivers = array();
    foreach ($product_items as $product_id => $product_item)
    {
        $money_amount = $product_item['price']['amount'] * $product_item['quantity'];
        $money_currency = $product_item['price']['currency_code'];
        $product_user = user_load($product_item['product']->uid);
        $product_user_email = token_replace('[user:field-paypal-adaptive-email]', array('user' => $product_user));
        $receiver_emails = array();
        foreach ($receivers as $key => $value)
        {
            $receiver_emails[] = $value['email'];
        }
        if (in_array($product_user_email, $receiver_emails))
        {
            foreach ($receivers as $key => $value)
            {
                if ($value['email'] === $product_user_email)
                {
                    $receivers[$key]['amount'] = number_format(((float)$receivers[$key]['amount'] + (float)commerce_paypal_price_amount(commerce_currency_convert($money_amount, $order_currency_code, $money_currency), $money_currency)), 2, '.', ''); //works, sort of, but not ideal, better multiply by 100 and divide again after
                }
            }
        }
        else
        {
            $receivers[] = array(
                'amount' => commerce_paypal_price_amount(commerce_currency_convert($money_amount, $order_currency_code, $money_currency), $money_currency),
                'email' => $product_user_email //,
                //'paymentType' => 'DIGITALGOODS'
            );
        }
        $receivers_counter++;
    }
    
    $calculate_paypal_fees_into_amounts = true;
    //dpm($receivers);
    // add fee to purchaser's checkout amount to unburden merchant, todo: make configurable from drupal web UI
    if ($calculate_paypal_fees_into_amounts === true)
    {
        foreach ($receivers as $key => $value)
        {
            // highest possible fee is 3.9% + 35 cents
            $receivers[$key]['amount'] = round(((float)$receivers[$key]['amount'] + 0.35) * 1.0416666666667, 2).'';
        }
    }
    //dpm($receivers);
    // //module_exists('token'))
    // $receivers = array(
    //   0 => array(
    //    'amount' => commerce_paypal_price_amount(commerce_currency_convert($amount, $order_currency_code, $currency_code), $currency_code),
    //    'email' =>  token_replace('[user:field-paypal-adaptive-email]', array('user' => $product_user))),
    // );
    
    return $receivers;
}

/**
 * Payment method callback: redirect form, a wrapper around the module's general
 *   use function for building a adaptive form.
 */
function commerce_paypal_adaptive_redirect_form($form, &$form_state, $order, $payment_method) {
  //dd(__FUNCTION__, date("h:i:s" ,time()));
  //dd(ddebug_backtrace(true));
  
  // Return an error if the enabling action's settings haven't been configured.
  if (empty($payment_method['settings']['application_id']) ||
    empty($payment_method['settings']['api_username']) ||
    empty($payment_method['settings']['api_password']) ||
    empty($payment_method['settings']['api_signature'])) {
    drupal_set_message(t('PayPal Adaptive is not configured for use.'), 'error');
    return array();
  }

  $settings = array(
    // Return to the previous page when payment is canceled
    'cancel_return' => url('checkout/' . $order->order_id . '/payment/back/' . $order->data['payment_redirect_key'], array('absolute' => TRUE)),

    // Return to the payment redirect page for processing successful payments
    'return' => url('checkout/' . $order->order_id . '/payment/return/' . $order->data['payment_redirect_key'], array('absolute' => TRUE)),

    // Specify the current payment method instance ID in the notify_url
    'payment_method' => $payment_method['instance_id'],
  );

  return commerce_paypal_adaptive_order_form($form, $form_state, $order, $payment_method['settings'] + $settings);
}

/**
 * Payment method callback: redirect form return validation.
 */
function commerce_paypal_adaptive_redirect_form_validate($order, $payment_method)
{
    //dd(__FUNCTION__, date("h:i:s" ,time()));
    if (!empty($payment_method['settings']['ipn_logging']) && $payment_method['settings']['ipn_logging'] == 'full_ipn')
    {
        watchdog('commerce_paypal_adaptive', 'Customer returned from PayPal with the following POST data:!ipn_data', array('!ipn_data' => '<pre>' . check_plain(print_r($_POST, TRUE)) . '</pre>'), WATCHDOG_NOTICE);
    }
    
    // This may be an unnecessary step, but if for some reason the user does end
    // up returning at the success URL with a Failed payment, go back.
    if (!empty($_POST['payment_status']) && $_POST['payment_status'] == 'Failed')
    {
        return FALSE;
    }
    $receivers = commerce_paypal_adaptive_get_receivers($order);
    //dpm($receivers);
    if (count($receivers) == 1)
    {
        //dpm($order->data);
        
        $settings = $payment_method['settings'];
        $application_id = $settings['application_id'];
        $api_username = $settings['api_username'];
        $api_password = $settings['api_password'];
        $api_signature = $settings['api_signature'];
        $server = $settings['server'];
        
        $record = db_select('commerce_paypal_adaptive_pay_chain', 'cpcpc')
                            ->fields('cpcpc', array('pay_key', 'currency', 'data'))
                            ->condition('cpcpc.order_id', $order->order_id)
                            ->execute()
                            ->fetch();
        // Don't attempt to verify the Express Checkout details without a valid token.
        if (!empty($record->pay_key))
        {
            //dpm($record);
            //dpm($record->pay_key);
            //dpm($record->currency);
            $currency_code = $record->currency;
            //dpm($record->data);
            $payment_data = unserialize($record->data);
            $paypal_token = $record->pay_key;
            
            $order_amount = $receivers[0]['amount'];
            $paypal_amount = $payment_data[0]['amount'];
            $paypal_fee_amount = $paypal_amount - $order_amount;
            
            if ($server === 'sandbox')
            {
                $application_id = 'APP-80W284485P519543T'; // See https://developer.paypal.com/docs/classic/lifecycle/sb_credentials/
            }
            
            // construct request
            
            $paypal_nvp_data = array();
                $paypal_nvp_data['USER'] = $api_username;
                $paypal_nvp_data['PWD'] = $api_password;
                $paypal_nvp_data['SIGNATURE'] = $api_signature;
                $paypal_nvp_data['METHOD'] = 'GetExpressCheckoutDetails';
                $paypal_nvp_data['VERSION'] = 93;
                $paypal_nvp_data['TOKEN'] = $paypal_token;
            //dpm($paypal_nvp_data);
            $paypal_nvp_string = http_build_query($paypal_nvp_data, '', '&', PHP_QUERY_RFC3986);
            //dpm($paypal_nvp_string);
            
            $ch;
            switch ($server)
            {
                case 'sandbox':
                {
                    $ch = curl_init('https://api-3t.sandbox.paypal.com/nvp');
                    break;
                }
                case 'live':
                {
                    $ch = curl_init('https://api-3t.paypal.com/nvp');
                    break;
                }
            }
            
            // We'll be sending POST data
            curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "POST");
            // The data is our JSON string
            curl_setopt($ch, CURLOPT_POSTFIELDS, $paypal_nvp_string);
            // Instead of outputting the response, return it in a string as the result
            // of our call to curl_exec().
            curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
            // Set our request headers
            curl_setopt($ch, CURLOPT_HTTPHEADER, array(
            //'Content-Type: application/json',
            'Content-Length: ' . strlen($paypal_nvp_string),
            //'X-PAYPAL-SECURITY-USERID: ' . $api_username,
            //'X-PAYPAL-SECURITY-PASSWORD: ' . $api_password,
            //'X-PAYPAL-SECURITY-SIGNATURE: ' . $api_signature,
            //'X-PAYPAL-REQUEST-DATA-FORMAT: JSON',
            //'X-PAYPAL-RESPONSE-DATA-FORMAT: JSON',
            //'X-PAYPAL-APPLICATION-ID: ' . $application_id,
            ));
            // Execute this request, storing the result
            $result = curl_exec($ch);
            // All done with cURL, close our connection
            curl_close($ch);
            // Our response was in NVP, so decode it into an array
            $nvpSerialized = array();
            parse_str($result, $nvpSerialized);
            $result = $nvpSerialized;
            // If PayPal gave us an acknowledgement of success and a paykey, proceed
            //if (strtolower($result->responseEnvelope->ack) == 'success' && !empty($result->payKey))
            // {
            // Return the PayKey
            //  return $result->payKey;
            //}
            //dpm($order);
            //dpm($result);
            if (isset($result['ACK']) && $result['ACK'] == 'Success' && isset($result['PAYERID']))
            {
                $paypal_payerId = $result['PAYERID'];
                // Use the commerce_paypal ipn invoice number so we associate the IPN response
                // with this order when it comes back.
                $tracking_id = commerce_paypal_ipn_invoice($order);
                // We've defined our own IPN url for this module, which is why we're not using
                // commerce_paypal_ipn_url() here.
                $ipn_url = url('commerce_paypal/paypal-adaptive/ipn', array('absolute' => TRUE));
                
                // If the user is anonymous, add their PayPal e-mail to the order.
                //if (empty($order->mail))
                //{
                    $order->mail = $result['EMAIL']; //on second thought... always do this
                //}
                // Create a billing information profile for the order with the available info.
                commerce_paypal_adaptive_express_customer_profile($order, 'billing', $result, 'PAYMENTREQUEST_0_');
                
                // If the shipping module exists on the site, create a shipping information
                // profile for the order with the available info.
                if (module_exists('commerce_shipping'))
                {
                    commerce_paypal_adaptive_express_customer_profile($order, 'shipping', $result, 'PAYMENTREQUEST_0_');
                }
                
                // ring the transaction through
                $paypal_transact_nvp_data = array(
                    'USER' => $api_username,
                    'PWD' => $api_password,
                    'SIGNATURE' => $api_signature,
                    'METHOD' => 'DoExpressCheckoutPayment',
                    'VERSION' => 93,
                    'TOKEN' => $paypal_token,
                    'PAYERID' => $paypal_payerId,
                    'PAYMENTREQUEST_0_PAYMENTACTION' => 'SALE',
                    'PAYMENTREQUEST_0_AMT' => $paypal_amount,
                    'PAYMENTREQUEST_0_CURRENCYCODE' => $currency_code,
                    'PAYMENTREQUEST_0_INVNUM' => $tracking_id, // $order->order_number,
                    'PAYMENTREQUEST_0_NOTIFYURL' => commerce_paypal_ipn_url($payment_method['instance_id'])
                );
                $paypal_transact_nvp_data += commerce_paypal_adaptive_itemize_order($order, $receivers[0]);
                //dpm($paypal_transact_nvp_data);
                $paypal_transact_nvp_string = http_build_query($paypal_transact_nvp_data, '', '&', PHP_QUERY_RFC3986);
                //dpm($paypal_transact_nvp_string);
                $txn;
                switch ($server)
                {
                    case 'sandbox':
                    {
                        $txn = curl_init('https://api-3t.sandbox.paypal.com/nvp');
                        break;
                    }
                    case 'live':
                    {
                        $txn = curl_init('https://api-3t.paypal.com/nvp');
                        break;
                    }
                }
                // We'll be sending POST data
                curl_setopt($txn, CURLOPT_CUSTOMREQUEST, "POST");
                // The data is our JSON string
                curl_setopt($txn, CURLOPT_POSTFIELDS, $paypal_transact_nvp_string);
                // Instead of outputting the response, return it in a string as the result
                // of our call to curl_exec().
                curl_setopt($txn, CURLOPT_RETURNTRANSFER, TRUE);
                // Set our request headers
                curl_setopt($txn, CURLOPT_HTTPHEADER, array(
                //'Content-Type: application/json',
                'Content-Length: ' . strlen($paypal_transact_nvp_string),
                //'X-PAYPAL-SECURITY-USERID: ' . $api_username,
                //'X-PAYPAL-SECURITY-PASSWORD: ' . $api_password,
                //'X-PAYPAL-SECURITY-SIGNATURE: ' . $api_signature,
                //'X-PAYPAL-REQUEST-DATA-FORMAT: JSON',
                //'X-PAYPAL-RESPONSE-DATA-FORMAT: JSON',
                //'X-PAYPAL-APPLICATION-ID: ' . $application_id,
                ));
                // Execute this request, storing the result
                $txn_result = curl_exec($txn);
                // All done with cURL, close our connection
                curl_close($txn);
                // Our response was in NVP, so decode it into an array
                $txnNvpSerialized = array();
                parse_str($txn_result, $txnNvpSerialized);
                $txn_result = $txnNvpSerialized;
                //dpm($txnNvpSerialized);
                // If the request failed, exit now with a failure message.
                if (!isset($txn_result['ACK']) || $txn_result['ACK'] != 'Success')
                {
                    return FALSE;
                }
                else if ($txn_result['ACK'] === 'Success')
                {
                    // we could mark the order as paid in full here
                    if (empty($order->data['commerce_payment_order_paid_in_full_invoked']))
                    {
                        //create a commerce transaction
                        $charge = $order->commerce_order_total['und'][0];
                        $transaction = commerce_payment_transaction_new('paypal_adaptive', $order->order_id);
                        $transaction->instance_id = $payment_method['instance_id'];
                        $transaction->amount = $charge['amount'];
                        $transaction->currency_code = $charge['currency_code'];
                        $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
                        $transaction->message = 'Name: @name';
                        $transaction->message_variables = array('@name' => 'PayPal payment');
                        commerce_payment_transaction_save($transaction);
                        commerce_payment_commerce_payment_transaction_insert($transaction);
                        
                        // Check the order balance and invoke the event.
                        $balance = commerce_payment_order_balance($order);
                        //dpm($balance);
                        
                        if ($balance['amount'] <= 0)
                        {
                            // Invoke the event including a hook of the same name.
                            rules_invoke_all('commerce_payment_order_paid_in_full', $order, $transaction);
                    
                            // Update the order's data array to indicate this just happened.
                            $order->data['commerce_payment_order_paid_in_full_invoked'] = TRUE;
                    
                            // Save the updated order.
                            commerce_order_save($order);
                        }
                    }
                }
            }
            else
            {
                return false;
            }
        }
        else
        {
            return false;
        }
    }
}

/**
 * Loads a stored adaptive payment IPN by ID.
 *
 * @param $id
 *   The ID of the IPN to load.
 * @param $type
 *   The type of ID you've specified, either the serial numeric ipn_id or the
 *     actual PayPal pay_key. Defaults to pay_key.
 *
 * @return
 *   The original IPN with some meta data related to local processing.
 */
function commerce_paypal_adaptive_ipn_load($id, $type = 'pay_key') {
  //dd(__FUNCTION__, date("h:i:s" ,time()));
  // Grab the base IPN array
  $ipn = db_select('commerce_paypal_adaptive_ipn', 'cpci')
    ->fields('cpci')
    ->condition('cpci.' . $type, $id)
    ->execute()
    ->fetchAssoc();
  // Grab this IPN's transactions (adaptive payments)
  $result = db_select('commerce_paypal_adaptive_ipn_transaction', 'cpcit')
    ->fields('cpcit')
    ->condition('cpcit.ipn_transaction_id', $ipn['ipn_id'])
    ->execute();
  // Add these adaptive transactions into the IPN
  while ($record = $result->fetchAssoc()) {
    $ipn['transaction'][] = $record;
  }
  return $ipn;
}

/**
 * Saves an IPN with some meta data related to local processing.
 *
 * @param $ipn
 *   An IPN array with additional parameters associated with the IPN.
 *
 * @return
 *   TRUE on success, FALSE on failure; since the IPN is received by reference,
 *     it will also contain the serial numeric ipn_id used locally.
 */
function commerce_paypal_adaptive_ipn_save(&$ipn) {
  //dd(__FUNCTION__, date("h:i:s" ,time()));
  // Split our transactions off of our IPN since they get stored in different
  // tables
  $ipn_transactions = $ipn['transaction'];
  unset($ipn['transaction']);
  if (!empty($ipn['ipn_id']) && commerce_paypal_adaptive_ipn_load($ipn['pay_key'])) {
    // Pre-existing IPN
    // Update the changed timestamp in this IPN
    $ipn['changed'] = REQUEST_TIME;
    // Attempt to save the IPN
    if (drupal_write_record('commerce_paypal_adaptive_ipn', $ipn, 'ipn_id')) {
      // Success - store the ipn transactions
      if (commerce_paypal_adaptive_ipn_transactions_save($ipn_transactions, $ipn['ipn_id'])) {
        $ipn['transaction'] = $ipn_transactions;
        return TRUE;
      }
      else {
        return FALSE;
      }
    }
    else {
      return FALSE;
    }
  }
  else {
    // New IPN
    $ipn['created'] = REQUEST_TIME;
    $ipn['changed'] = REQUEST_TIME;
    // Attempt to save the IPN
    if (drupal_write_record('commerce_paypal_adaptive_ipn', $ipn)) {
      // Success - store the ipn transactions
      if (commerce_paypal_adaptive_ipn_transactions_save($ipn_transactions, $ipn['ipn_id'])) {
        $ipn['transaction'] = $ipn_transactions;
        return TRUE;
      }
      else {
        return FALSE;
      }
    }
    else {
      return FALSE;
    }
  }
}

/**
 * Saves an IPN's transactions with some meta data related to local processing.
 *
 * @param $ipn_transactions
 *   An IPN transactions array.
 * @param $ipn_id
 *   The ipn_id of the parent IPN.
 *
 * @return
 *   TRUE on success, FALSE on failure; since the IPN transactions are
 *     received by reference, they will also contain the serial numeric
 *      ipn_transaction_ids used locally.
 */
function commerce_paypal_adaptive_ipn_transactions_save(&$ipn_transactions, $ipn_id) {
  //dd(__FUNCTION__, date("h:i:s" ,time()));

  foreach ($ipn_transactions as $key => $ipn_transaction) {
    // Associate this ipn transaction with its parent IPN
    $ipn_transaction['ipn_id'] = $ipn_id;
    // Break out currency code and gross transaction amount from the amount line
    list($ipn_transaction['currency'], $ipn_transaction['gross']) = explode(' ', $ipn_transaction['amount']);
    if (!empty($ipn_transaction['ipn_transaction_id'])) {
      // Pre-existing ipn transaction
      if (drupal_write_record('commerce_paypal_adaptive_ipn_transaction', $ipn_transaction, 'ipn_transaction_id')) {
        // drupal_write_record() may have updated our transaction - so store it
        $ipn_transactions[$key] = $ipn_transaction;
      }
      else {
        // Return false on failure to write this record
        return FALSE;
      }
    }
    else {
      if (drupal_write_record('commerce_paypal_adaptive_ipn_transaction', $ipn_transaction)) {
        // drupal_write_record() updated our transaction - so store it
        $ipn_transactions[$key] = $ipn_transaction;
      }
      else {
        // Return false on failure to write this record
        return FALSE;
      }
    }
  }
  return TRUE;
}

/**
 * Deletes a stored adaptive payment IPN by ID.
 *
 * @param $id
 *   The ipn_id of the IPN you wish to delete.
 */
function commerce_paypal_adaptive_ipn_delete($id) {
  // Delete out any of this IPN's adaptive transactions
  db_delete('commerce_paypal_adaptive_ipn_transaction')
    ->condition('ipn_id', $id)
    ->execute();
  // Delete the IPN itself
  db_delete('commerce_paypal_adaptive_ipn')
    ->condition('ipn_id', $id)
    ->execute();
}

/**
 * Processes an incoming adaptive payment IPN.
 *
 * @param $debug_ipn
 *   Optionally specify an IPN array for debug purposes; if left empty, the IPN
 *     be pulled from php://input. If an IPN is passed in, validation of the IPN
 *     at PayPal will be bypassed.
 *
 * @return
 *   TRUE or FALSE indicating whether the IPN was successfully processed or not.
 */
function commerce_paypal_adaptive_process_ipn($debug_ipn = array()) {
  //dd(__FUNCTION__, date("h:i:s" ,time()));
  // Load up our payment method instance array
  $payment_method = commerce_payment_method_instance_load('paypal_adaptive|commerce_payment_paypal_adaptive');
  // Retrieve the IPN from $_POST if the caller did not supply an IPN array.
  // Note that Drupal has already run stripslashes() on the contents of the
  // $_POST array at this point, so we don't need to worry about them.
  if (empty($debug_ipn)) {
    // We can't rely on $_POST for our IPN vars because PayPal sends them back
    // nested in such a way that PHP can't interpret the nested transactions
    // array
    // So in this case we have nested POST data we have to parse into an array
    // by hand
    $raw_ipn = file_get_contents("php://input");
    // Exit now if we have no ipn data.
    if (empty($raw_ipn)) {
      watchdog('commerce_paypal_adaptive', 'IPN URL accessed with no POST data submitted.', array(), WATCHDOG_WARNING);
      return FALSE;
    }
    // Decode the URL-encoded bits
    $decoded_ipn = urldecode($raw_ipn);
    // Break apart our variables
    $vars = explode('&', $decoded_ipn);
    // Initialize the array we'll be filling
    $ipn = array();
    foreach ($vars as $var) {
      // First, split our data pairs up on the first '='
      list($key, $value) = explode('=', $var, 2);
      // So, if $key contains '[x]' then we're looking at data that's part of an
      // array
      // PayPal's format is basically "variable-name[iteration].property-name = value"
      // We'll turn this into $ipn['variable-name'][iteration]['property-name'] = value so we
      // can work with this data in PHP
      if (preg_match("/.*?(\\d+)/is", $key, $matches)) {
        // We are looking at an array
        // Grab the variable name
        $variable_name = substr($key, 0, strpos($key, '['));
        // Our iteration is the integer x in "[x]", which is stored in $matches[1]
        $iteration = $matches[1];
        // Grab the property name
        $property_name = substr($key, strpos($key, '.') + 1);
        // Ok - we have what we need to store this
        $ipn[$variable_name][$iteration][$property_name] = $value;
      }
      else {
        // This is just a regular key-value pair so store as such
        $ipn[$key] = $value;
      }
    }
    // Exit now if we have no pay key
    if (empty($ipn['pay_key'])) {
      watchdog('commerce_paypal_adaptive', 'IPN URL accessed with no pay_key in POST data submitted.', array(), WATCHDOG_WARNING);
      return FALSE;
    }

    // IPN validation time...
    // Basically, verify with PayPal that it just sent us this message

    // Determine the proper PayPal server to POST to.
    if (!empty($ipn['test_ipn']) && $ipn['test_ipn'] == 1) {
      $host = 'https://www.sandbox.paypal.com/cgi-bin/webscr';
    }
    else {
      $host = 'https://www.paypal.com/cgi-bin/webscr';
    }

    // Process the HTTP request to validate the IPN.
    $response = drupal_http_request($host, array('method' => 'POST', 'data' => 'cmd=_notify-validate&' . $raw_ipn));

    // If an error occurred during processing, log the message and exit.
    if (property_exists($response, 'error')) {
      watchdog('commerce_paypal_adaptive', 'Attempt to validate IPN failed with error @code: @error', array('@code' => $response->code, '@error' => $response->error), WATCHDOG_ERROR);
      return FALSE;
    }

    // If the IPN was invalid, log a message and exit.
    if ($response->data == 'INVALID') {
      watchdog('commerce_paypal_adaptive', 'Invalid IPN received and ignored.', array(), WATCHDOG_ALERT);
      return FALSE;
    }
  }
  else {
    $ipn = $debug_ipn;
  }

  // If the payment method specifies full IPN logging, do it now.
  if (!empty($payment_method['settings']['ipn_logging']) &&
    $payment_method['settings']['ipn_logging'] == 'full_ipn') {
    if (!empty($ipn['pay_key'])) {
      watchdog('commerce_paypal_adaptive', 'Attempting to process IPN @pay_key. !ipn_log', array('@pay_key' => $ipn['pay_key'], '!ipn_log' => '<pre>' . check_plain(print_r($ipn, TRUE)) . '</pre>'), WATCHDOG_NOTICE);
    }
    else {
      watchdog('commerce_paypal_adaptive', 'Attempting to process an IPN. !ipn_log', array('!ipn_log' => '<pre>' . check_plain(print_r($ipn, TRUE)) . '</pre>'), WATCHDOG_NOTICE);
    }
  }

  // Exit if the IPN has already been processed.
  if (!empty($ipn['pay_key']) && $prior_ipn = commerce_paypal_adaptive_ipn_load($ipn['pay_key'])) {
    // TODO
    // Dive down into each item in the pay chain checking status - if all
    // statuses match what they were the last time around, we've already seen
    // this.  Otherwise - if a status is different then we need to adjust the
    // transaction associated with that adaptive payment in
    // commerce_paypal_adaptive_paypal_ipn_process().
    // TODO - verify IPNs are sent out when any piece of the chain changes
    // For now - we only accept one IPN with this paykey
    watchdog('commerce_paypal_adaptive', 'Attempted to process an IPN that has already been processed with transaction ID @pay_key.', array('@pay_key' => $ipn['pay_key']), WATCHDOG_NOTICE);
    return FALSE;
  }

  // Load the order based on the IPN's invoice number, which we've stored in
  // tracking_id.
  if (!empty($ipn['tracking_id']) && strpos($ipn['tracking_id'], '-') !== FALSE) {
    list($ipn['order_id'], $timestamp) = explode('-', $ipn['tracking_id']);
  }
  elseif (!empty($ipn['tracking_id'])) {
    $ipn['order_id'] = $ipn['tracking_id'];
  }
  else {
    $ipn['order_id'] = 0;
    $timestamp = 0;
  }

  if (!empty($ipn['order_id'])) {
    $order = commerce_order_load($ipn['order_id']);
  }
  else {
    $order = FALSE;
  }
  // Give the payment method module an opportunity to validate the receiver
  // e-mail address and amount of the payment if possible. If a validate
  // function exists, it is responsible for setting its own watchdog message.
  if (!empty($payment_method)) {
    $callback = $payment_method['base'] . '_paypal_ipn_validate';

    // If a validator function existed...
    if (function_exists($callback)) {
      // Only exit if the function explicitly returns FALSE.
      if ($callback($order, $payment_method, $ipn) === FALSE) {
        return FALSE;
      }
    }
  }

  // Give the payment method module an opportunity to process the IPN.
  if (!empty($payment_method)) {
    $callback = $payment_method['base'] . '_paypal_ipn_process';

    // If a processing function existed...
    if (function_exists($callback)) {
      // Skip saving if the function explicitly returns FALSE, meaning the IPN
      // wasn't actually processed.
      if ($callback($order, $payment_method, $ipn) !== FALSE) {
        // Save the processed IPN details.
        commerce_paypal_adaptive_ipn_save($ipn);
      }
    }
  }

  // Invoke the hook here so implementations have access to the order and
  // payment method if available and a saved IPN array that includes the payment
  // transaction ID if created in the payment method's default process callback.
  module_invoke_all('commerce_paypal_ipn_process', $order, $payment_method, $ipn);
}

/**
 * Payment method callback: validate an IPN based on receiver e-mail address,
 *   price, and other parameters as possible.
 */
function commerce_paypal_adaptive_paypal_ipn_validate($order, $payment_method, $ipn) {
  //dd(__FUNCTION__, date("h:i:s" ,time()));
  // Return FALSE if chain described in this IPN doesn't match the chain we have
  // recorded for this order
  $record = db_select('commerce_paypal_adaptive_pay_chain', 'cpcpc')
    ->fields('cpcpc', array('currency', 'data'))
    ->condition('cpcpc.order_id', $order->order_id)
    ->execute()
    ->fetch();
  if (!empty($record->data)) {
    // The chain array is held in a serialized data field
    $known_chain = unserialize($record->data);
    // First off - are we looking at the same number of receivers?
    if (count($known_chain) == count($ipn['transaction'])) {
      // Loop through the ipn transactions chain verifying the values match our
      // known chain
      foreach ($ipn['transaction'] as $key => $ipn_transaction) {
        // Break out our currency code and transaction amount
        list($currency, $gross) = explode(' ', $ipn_transaction['amount']);
        // Test for consistency with what we have on file
        if ($gross != $known_chain[$key]['amount'] ||
          $ipn_transaction['receiver'] != $known_chain[$key]['email'] ||
          $currency != $record->currency ||
          $ipn_transaction['is_primary_receiver'] != $known_chain[$key]['primary']) {
          watchdog('commerce_paypal_adaptive', 'IPN rejected: invalid pay chain specified for Order @order_number; must match the pay chain on file for this order.', array('@order_number' => $order->order_number), WATCHDOG_NOTICE);
          return FALSE;
        }
      }
    }
    else {
      watchdog('commerce_paypal_adaptive', 'IPN rejected: invalid pay chain specified for Order @order_number; wrong number of receivers.', array('@order_number' => $order->order_number), WATCHDOG_NOTICE);
      return FALSE;
    }
  }
  else {
    watchdog('commerce_paypal_adaptive', 'IPN rejected: no pay chain on file for Order @order_number.', array('@order_number' => $order->order_number), WATCHDOG_NOTICE);
    return FALSE;
  }

  // Prepare the IPN data for inclusion in the watchdog message if enabled.
  $ipn_data = '';

  if (!empty($payment_method['settings']['ipn_logging']) &&
    $payment_method['settings']['ipn_logging'] == 'full_ipn') {
    $ipn_data = '<pre>' . check_plain(print_r($ipn, TRUE)) . '</pre>';
  }

  // Log a message including the PayPal transaction ID if available.
  if (!empty($ipn['pay_key'])) {
    watchdog('commerce_paypal_adaptive', 'IPN validated for Order @order_number with ID @pay_key.!ipn_data', array('@order_number' => $order->order_number, '@pay_key' => $ipn['pay_key'], '!ipn_data' => $ipn_data), WATCHDOG_NOTICE);
  }
  else {
    watchdog('commerce_paypal_adaptive', 'IPN validated for Order @order_number.!ipn_data', array('@order_number' => $order->order_number, '!ipn_data' => $ipn_data), WATCHDOG_NOTICE);
  }
}

/**
 * Payment method callback: process an IPN once it's been validated.
 */
function commerce_paypal_adaptive_paypal_ipn_process($order, $payment_method, &$ipn) {
  //dd(__FUNCTION__, date("h:i:s" ,time()));
  // For now, we only recognize COMPLETED paychains
  // Exit when we don't get a payment status of COMPLETED.
  if ($ipn['status'] != 'COMPLETED') {
    commerce_payment_redirect_pane_previous_page($order);
    return FALSE;
  }
  // Great - we're looking at a completed adaptive payment
  // Store each of the effective payments as commerce transactions
  foreach ($ipn['transaction'] as $key => $ipn_transaction) {
    $transaction = commerce_payment_transaction_new('paypal_adaptive', $order->order_id);
    $transaction->instance_id = $payment_method['instance_id'];
    $transaction->remote_id = $ipn['pay_key'];
    $transaction->field_adaptive_receiver_email[LANGUAGE_NONE][0]['value'] = $ipn_transaction['receiver'];
    // amount contains the currency code and the transaction amount
    list($transaction->currency_code, $transaction->amount) = explode(' ', $ipn_transaction['amount']);
/*
    // If this is the primary transaction, deduct the secondary transactions
    // from it (leaving the primary transaction with what the primary receiver
    // effectively received when all was said and done).  This helps describe
    // who got paid what on the payments tab of an order, and ensures the sum
    // of all of the payments totals to the order total.
    if ($ipn_transaction['is_primary_receiver'] == 'true') {
      foreach ($ipn['transaction'] as $ipn_transaction_inner) {
        if ($ipn_transaction_inner['is_primary_receiver'] == 'false') {
          list( , $inner_amount) = explode(' ', $ipn_transaction_inner['amount']);
          $transaction->amount -= $inner_amount;
        }
      }
    }
*/
    // Convert our amount from a decimal back to an integer for storage in the
    // database.
    $transaction->amount = commerce_currency_decimal_to_amount($transaction->amount, $transaction->currency_code);
    $transaction->payload[REQUEST_TIME . '-ipn'] = $ipn;
    // Set the transaction's statuses based on the IPN transaction's status.
    $transaction->remote_status = $ipn_transaction['status'];
    // Set our internal transaction status
    switch ($ipn_transaction['status']) {
      case 'Pending':
        $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
        $transaction->message = t('The payment is pending.');
        break;

      case 'Completed':
        $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
        $transaction->message = t('The payment has completed.');
        break;

      case 'Refunded':
        $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
        $transaction->message = t('Refund for transaction @pay_key', array('@pay_key' => $ipn['parent_txn_id']));
        break;
    }
    // Save the transaction information.
    commerce_payment_transaction_save($transaction);
    $ipn['transaction'][$key]['transaction_id'] = $transaction->transaction_id;
  }
  commerce_payment_redirect_pane_next_page($order);
  watchdog('commerce_paypal_adaptive', 'IPN processed for Order @order_number with ID @pay_key.', array('@pay_key' => $ipn['pay_key'], '@order_number' => $order->order_number), WATCHDOG_INFO);
}

/**
 * Builds a Website Payments Standard form from an order object.
 *
 * @param $order
 *   The fully loaded order being paid for.
 * @param $settings
 *   An array of settings used to build out the form, including:
 *   - server: which server to use, either sandbox or live
 *   - business: the PayPal e-mail address the payment submits to
 *   - cancel_return: the URL PayPal should send the user to on cancellation
 *   - return: the URL PayPal should send the user to on successful payment
 *   - currency_code: the PayPal currency code to use for this payment if the
 *     total for the order is in a non-PayPal supported currency
 *   - language: the PayPal language code to use on the payment form
 *   - payment_action: the PayPal payment action to use: sale, authorization,
 *     or order
 *   - payment_method: optionally a payment method instance ID to include in the
 *     IPN notify_url
 *
 * @return
 *   A renderable form array.
 */
function commerce_paypal_adaptive_order_form($form, &$form_state, $order, $settings)
{
    //dd($order, 'order');
    
    $wrapper = entity_metadata_wrapper('commerce_order', $order);
    //dd($wrapper, 'wrapper');
    
    // Determine the currency code to use to actually process the transaction,
    // which will either be the default currency code or the currency code of the
    // order if it's supported by PayPal if that option is enabled.
    $currency_code = $settings['currency_code'];
    $order_currency_code = $wrapper->commerce_order_total->currency_code->value();
    if (!empty($settings['allow_supported_currencies']) && in_array($order_currency_code, array_keys(commerce_paypal_currencies('paypal_adaptive'))))
    {
        $currency_code = $order_currency_code;
    }
    $amount = $wrapper->commerce_order_total->amount->value();
    // Ensure a default value for the payment_method setting.
    $settings += array('payment_method' => '');
    // Populate the receivers array (define our adaptive payment)
    // We'll define the first receiver as our primary
    
    $receivers = commerce_paypal_adaptive_get_receivers($order);
        // gotta figure out how to deal with and throw an error if there are more than six (6) receivers, which PayPal won't allow...
    
    $memo = t('Order @order_number at @store', array('@order_number' => $order->order_number, '@store' => variable_get('site_name', url('<front>', array('absolute' => TRUE)))));
    // Use the commerce_paypal ipn invoice number so we associate the IPN response
    // with this order when it comes back.
    $tracking_id = commerce_paypal_ipn_invoice($order);
    // We've defined our own IPN url for this module, which is why we're not using
    // commerce_paypal_ipn_url() here.
    $ipn_url = url('commerce_paypal/paypal-adaptive/ipn', array('absolute' => TRUE));
    // Reach out to PayPal for a paykey to associate with this order
    // The Pay Key essentially defines our adaptive payment on PayPal's end, and
    // we'll need to pass this, along with the user, over to PayPal.
    $pay_key;
    if (count($receivers) > 1)
    {
        $pay_key = commerce_paypal_adaptive_get_paykey(
            $receivers,
            $memo,
            $tracking_id,
            $settings['application_id'],
            $currency_code,
            $settings['cancel_return'],
            $settings['return'],
            $ipn_url,
            $settings['server'],
            $settings['api_username'],
            $settings['api_password'],
            $settings['api_signature']
        );
    }
    else
    {
        $pay_key = commerce_paypal_adaptive_get_incontext_token(
            $order,
            $receivers,
            $memo,
            $tracking_id,
            $settings['application_id'],
            $currency_code,
            $settings['cancel_return'],
            $settings['return'],
            $ipn_url,
            $settings['server'],
            $settings['api_username'],
            $settings['api_password'],
            $settings['api_signature']
        );
    }
    // If we got a pay key back, then we're clear to transact with these settings,
    // in which case we'll store a copy of the chain details for IPN validation
    if (!empty($pay_key)) {
        // If a previous pay chain was associated with this order, delete it
        // Add db_table_exists for development purpose
        if (db_table_exists('commerce_paypal_adaptive_pay_chain'))
        db_delete('commerce_paypal_adaptive_pay_chain')
            ->condition('order_id', $order->order_id)
            ->execute();
        // Store our order's pay chain, as we've defined it above
        $pay_chain = array(
        'order_id' => $order->order_id,
        'pay_key' => $pay_key,
        'currency' => $currency_code,
        'data' => $receivers,
        );
        drupal_write_record('commerce_paypal_adaptive_pay_chain', $pay_chain);
    }
    // Set our form action to
    if (count($receivers) > 1)
    {
        $form['#action'] = commerce_paypal_adaptive_server_url($settings['server']).$pay_key;
    }
    else
    {
        $form['#action'] = commerce_paypal_incontext_server_url($settings['server']).$pay_key;
    }
    $form['submit'] = array(
        '#type' => 'submit',
        '#value' => t('Proceed to PayPal'),
    );
    return $form;
}

/**
 * Returns the URL to the specified PayPal Adaptive server.
 *
 * @param $server
 *   Either sandbox or live indicating which server to get the URL for.
 *
 * @return
 *   The URL to use to submit requests to the PayPal Adaptive server.
 */
function commerce_paypal_adaptive_server_url($server)
{
    //dd(__FUNCTION__, date("h:i:s" ,time()));
    switch ($server)
    {
        case 'sandbox':
        {
            return 'https://www.sandbox.paypal.com/cgi-bin/webscr?cmd=_ap-payment&paykey=';
            //return 'https://www.sandbox.paypal.com/webapps/adaptivepayment/flow/pay?expType=mini&paykey='; //this has nicer mobile layout, but will go horribly wrong when returning to site
        }
        case 'live':
        {
            return 'https://www.paypal.com/cgi-bin/webscr?cmd=_ap-payment&paykey=';
            //return 'https://www.paypal.com/webapps/adaptivepayment/flow/pay?expType=mini&paykey=';
        }
    }
}

/**
 * Returns the URL to the specified PayPal Express server.
 *
 * @param $server
 *   Either sandbox or live indicating which server to get the URL for.
 *
 * @return
 *   The URL to use to submit requests to the PayPal Adaptive server.
 */
function commerce_paypal_express_server_url($server)
{
    switch ($server)
    {
        case 'sandbox':
        {
            return 'https://www.sandbox.paypal.com/cgi-bin/webscr?cmd=_express-checkout&token=';
        }
        case 'live':
        {
            return 'https://www.paypal.com/cgi-bin/webscr?cmd=_express-checkout&token=';
        }
    }
}

/**
 * Returns the URL to the specified PayPal In-Context server.
 *
 * @param $server
 *   Either sandbox or live indicating which server to get the URL for.
 *
 * @return
 *   The URL to use to submit requests to the PayPal Adaptive server.
 */
function commerce_paypal_incontext_server_url($server)
{
    switch ($server)
    {
        case 'sandbox':
        {
            return 'https://www.sandbox.paypal.com/checkoutnow/2?incontext=1&token=';
        }
        case 'live':
        {
            return 'https://www.paypal.com/checkoutnow/2?incontext=1&token=';
        }
    }
}

/**
 * Returns an array of all possible language codes.
 */
function commerce_paypal_adaptive_languages() {
  return array(
    t('By country') => array(
      'AU' => t('Australia'),
      'AT' => t('Austria'),
      'BE' => t('Belgium'),
      'BR' => t('Brazil'),
      'CA' => t('Canada'),
      'CN' => t('China'),
      'FR' => t('France'),
      'DE' => t('Germany'),
      'IT' => t('Italy'),
      'NL' => t('Netherlands'),
      'PL' => t('Poland'),
      'PT' => t('Portugal'),
      'RU' => t('Russia'),
      'ES' => t('Spain'),
      'CH' => t('Switzerland'),
      'GB' => t('United Kingdom'),
      'US' => t('United States'),
    ),
    t('By language') => array(
      'da_DK' => t('Danish (for Denmark only)'),
      'he_IL' => t('Hebrew (for all)'),
      'id_ID' => t('Indonesian (for Indonesia only)'),
      'jp_JP' => t('Japanese (for Japan only)'),
      'no_NO' => t('Norwegian (for Norway only)'),
      'pt_BR' => t('Brazilian Portuguese (for Portugal and Brazil only)'),
      'ru_RU' => t('Russian (for Lithuania, Latvia, and Ukraine only)'),
      'sv_SE' => t('Swedish (for Sweden only)'),
      'th_TH' => t('Thai (for Thailand only)'),
      'tr_TR' => t('Turkish (for Turkey only)'),
      'zh_CN' => t('Simplified Chinese (for China only)'),
      'zh_HK' => t('Traditional Chinese (for Hong Kong only)'),
      'zh_TW' => t('Traditional Chinese (for Taiwan only)'),
    ),
  );
}

/**
 * Returns a PayPal Adaptive Payments PayKey for a proposed transaction.
 *
 * The total payment amount should be directed at the primary receiver, whom
 * the buyer will pay directly.  The subsequent receivers will then recieve
 * their payment amounts directly from the primary receiver.
 *
 * @param array $receivers
 *   An array of receivers of this payment, eg.,
 *    array(
 *      0 => array(
 *        'amount' => 10,
 *        'email' => 'receiver1@example.com',
 *        'primary' => 'true',
 *      ),
 *      1 => array(
 *        'amount' => 5,
 *        'email' => 'receiver2@example.com',
 *        'primary' => 'false',
 *      ),
 *    );
 * @param string $memo
 *   A note associated with the payment.
 * @param string $tracking_id
 *   A unique ID that you specify to track the payment.
 * @param string $application_id
 *   Your PayPal application's identification, issued by PayPal.
 * @param string $currency_code
 *   The code for the currency in which the payment is made.
 * @param string $cancel_url
 *   URL to redirect the sender's browser to after canceling the approval for
 *   a payment.
 * @param string $return_url
 *   URL to redirect the sender's browser to after the sender has logged into
 *   PayPal and approved a payment.
 * @param string $ipn_url
 *   The URL to which you want all IPN messages for this payment to be sent.
 * @param string $server
 *   Whether to use the sandbox or live (production) endpoint for this API
 *   call.
 * @param string $api_username
 *   Your PayPal API username.
 * @param string $api_password
 *   Your PayPal API password.
 * @param string $api_signature
 *   Your PayPal API signature.
 */
function commerce_paypal_adaptive_get_paykey($receivers, $memo = '', $tracking_id = '', $application_id, $currency_code, $cancel_url, $return_url, $ipn_url, $server = 'sandbox', $api_username, $api_password, $api_signature)
{
    // Build our payrequest
    //dd(__FUNCTION__, date("h:i:s" ,time()));
    if(isset($receivers) && count($receivers) > 6)
    {
        return false;
    }
    if ($server === 'sandbox')
    {
      $application_id = 'APP-80W284485P519543T'; // See https://developer.paypal.com/docs/classic/lifecycle/sb_credentials/
    }
    $pay_request = array(
      'actionType' => 'PAY',
      'receiverList' => array(
        'receiver' => $receivers,
      ),
      'memo' => $memo,
      'trackingId' => $tracking_id,
      'clientDetails' => array(
        'applicationId' => $application_id,
      ),
      'currencyCode' => $currency_code,
      'cancelUrl' => $cancel_url,
      'returnUrl' => $return_url,
      'ipnNotificationUrl' => $ipn_url,
      'requestEnvelope' => array(
        'errorLanguage' => 'en_US',
      ),
    );
    //dpm($pay_request);
    // Convert it to JSON
    $pay_request_json = json_encode($pay_request);
    // Initialize cURL with our desired API endpoint
    switch ($server)
    {
      case 'sandbox':
        $ch = curl_init('https://svcs.sandbox.paypal.com/AdaptivePayments/Pay');
        break;
      case 'live':
        $ch = curl_init('https://svcs.paypal.com/AdaptivePayments/Pay');
        break;
    }
    // We'll be sending POST data
    curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "POST");
    // The data is our JSON string
    curl_setopt($ch, CURLOPT_POSTFIELDS, $pay_request_json);
    // Instead of outputting the response, return it in a string as the result
    // of our call to curl_exec().
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
    // Set our request headers
    curl_setopt($ch, CURLOPT_HTTPHEADER, array(
      'Content-Type: application/json',
      'Content-Length: ' . strlen($pay_request_json),
      'X-PAYPAL-SECURITY-USERID: ' . $api_username,
      'X-PAYPAL-SECURITY-PASSWORD: ' . $api_password,
      'X-PAYPAL-SECURITY-SIGNATURE: ' . $api_signature,
      'X-PAYPAL-REQUEST-DATA-FORMAT: JSON',
      'X-PAYPAL-RESPONSE-DATA-FORMAT: JSON',
      'X-PAYPAL-APPLICATION-ID: ' . $application_id,
    ));
    // Execute this request, storing the result
    $result = curl_exec($ch);
    // All done with cURL, close our connection
    curl_close($ch);
    // Our response was in JSON, so decode it into a PHP object
    $result = json_decode($result);
    //dd($result, 'json_decode');
    // If PayPal gave us an acknowledgement of success and a paykey, proceed
    if (strtolower($result->responseEnvelope->ack) == 'success' && !empty($result->payKey))
    {
      // Return the PayKey
      return $result->payKey;
    }
    // Else something went wrong - PayPal didn't like what we sent
    else
    {
        return FALSE;
    }
}

/**
 * Returns a PayPal Express Checkout token for a proposed transaction.
 *
 * Only one receiver is allowed.
 *
 * @param array $receivers
 *   An array of receivers of this payment, eg.,
 *    array(
 *      0 => array(
 *        'amount' => 10,
 *        'email' => 'receiver1@example.com',
 *        'primary' => 'true',
 *      ),
 *    );
 * @param string $memo
 *   A note associated with the payment.
 * @param string $tracking_id
 *   A unique ID that you specify to track the payment.
 * @param string $application_id
 *   Your PayPal application's identification, issued by PayPal.
 * @param string $currency_code
 *   The code for the currency in which the payment is made.
 * @param string $cancel_url
 *   URL to redirect the sender's browser to after canceling the approval for
 *   a payment.
 * @param string $return_url
 *   URL to redirect the sender's browser to after the sender has logged into
 *   PayPal and approved a payment.
 * @param string $ipn_url
 *   The URL to which you want all IPN messages for this payment to be sent.
 * @param string $server
 *   Whether to use the sandbox or live (production) endpoint for this API
 *   call.
 * @param string $api_username
 *   Your PayPal API username.
 * @param string $api_password
 *   Your PayPal API password.
 * @param string $api_signature
 *   Your PayPal API signature.
 */

function commerce_paypal_adaptive_get_incontext_token($order, $receivers, $memo = '', $tracking_id = '', $application_id, $currency_code, $cancel_url, $return_url, $ipn_url, $server = 'sandbox', $api_username, $api_password, $api_signature)
{
    $receivers_count = count($receivers);
    if (isset($receivers) && $receivers_count > 0 && $receivers_count < 2)
    {
        // do stuff
        
        if ($server === 'sandbox')
        {
          $application_id = 'APP-80W284485P519543T'; // See https://developer.paypal.com/docs/classic/lifecycle/sb_credentials/
        }
        
        // construct request
        
        $paypal_nvp_data = array();
            $paypal_nvp_data['USER'] = $api_username;
            $paypal_nvp_data['PWD'] = $api_password;
            $paypal_nvp_data['SIGNATURE'] = $api_signature;
            $paypal_nvp_data['METHOD'] = 'SetExpressCheckout';
            $paypal_nvp_data['VERSION'] = 93;
            $paypal_nvp_data['PAYMENTREQUEST_0_PAYMENTACTION'] = 'SALE';
            $paypal_nvp_data['PAYMENTREQUEST_0_AMT'] = $receivers[0]['amount'];
            $paypal_nvp_data['PAYMENTREQUEST_0_CURRENCYCODE'] = $currency_code;
            $paypal_nvp_data['RETURNURL'] = $return_url;
            $paypal_nvp_data['CANCELURL'] = $cancel_url;
        $paypal_nvp_data += commerce_paypal_adaptive_itemize_order($order, $receivers[0]);
        //dpm($paypal_nvp_data);
        $paypal_nvp_string = http_build_query($paypal_nvp_data, '', '&', PHP_QUERY_RFC3986);
        //dpm($paypal_nvp_string);
        
        $ch;
        switch ($server)
        {
            case 'sandbox':
            {
                $ch = curl_init('https://api-3t.sandbox.paypal.com/nvp');
                break;
            }
            case 'live':
            {
                $ch = curl_init('https://api-3t.paypal.com/nvp');
                break;
            }
        }
        
        // We'll be sending POST data
        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "POST");
        // The data is our JSON string
        curl_setopt($ch, CURLOPT_POSTFIELDS, $paypal_nvp_string);
        // Instead of outputting the response, return it in a string as the result
        // of our call to curl_exec().
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
        // Set our request headers
        curl_setopt($ch, CURLOPT_HTTPHEADER, array(
          //'Content-Type: application/json',
          'Content-Length: ' . strlen($paypal_nvp_string),
          //'X-PAYPAL-SECURITY-USERID: ' . $api_username,
          //'X-PAYPAL-SECURITY-PASSWORD: ' . $api_password,
          //'X-PAYPAL-SECURITY-SIGNATURE: ' . $api_signature,
          //'X-PAYPAL-REQUEST-DATA-FORMAT: JSON',
          //'X-PAYPAL-RESPONSE-DATA-FORMAT: JSON',
          //'X-PAYPAL-APPLICATION-ID: ' . $application_id,
        ));
        // Execute this request, storing the result
        $result = curl_exec($ch);
        // All done with cURL, close our connection
        curl_close($ch);
        // Our response was in NVP, so decode it into an array
        $nvpSerialized = array();
        parse_str($result, $nvpSerialized);
        $result = $nvpSerialized;
        // If PayPal gave us an acknowledgement of success and a paykey, proceed
        //if (strtolower($result->responseEnvelope->ack) == 'success' && !empty($result->payKey))
       // {
          // Return the PayKey
        //  return $result->payKey;
        //}
        //dpm($result);
        if (isset($result['ACK']) && $result['ACK'] == 'Success' && isset($result['TOKEN']))
        {
            return $result['TOKEN'];
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
}

/**
 * Creates or updates a customer profile for an order based on information
 * obtained from PayPal after an Express Checkout.
 *
 * @param $order
 *   The order that was paid via Express Checkout.
 * @param $profile_type
 *   The type of the customer profile that should be created or updated.
 * @param $response
 *   The response array from a GetExpressCheckoutDetails API request.
 * @param $prefix
 *   The prefix for keys in the response array that will be used to populate the
 *   customer profile.
 * @param $skip_save
 *   Boolean indicating whether or not this function should skip saving the
 *   order after setting it to reference the newly created customer profile;
 *   defaults to TRUE, requiring the caller to save the order.
 */
function commerce_paypal_adaptive_express_customer_profile($order, $profile_type, $response, $prefix, $skip_save = TRUE)
{
    // First check if the order already references a customer profile of the
    // specified type.
    $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
    $field_name = variable_get('commerce_customer_profile_' . $profile_type . '_field', '');
    
    // If the associated order field has been set and the order currently
    // references a customer profile through it...
    if (!empty($field_name) && !empty($order_wrapper->{$field_name}))
    {
        // Update the existing customer profile.
        $profile = $order_wrapper->{$field_name}->value();
    }
    elseif (!empty($order->data['profiles']['customer_profile_' . $profile_type]))
    {
        // Otherwise look for an association stored in the order's data array.
        $profile = commerce_customer_profile_load($order->data['profiles']['customer_profile_' . $profile_type]);
    }
    
    // Create a new profile if we could not find an existing one.
    if (empty($profile))
    {
        $profile = commerce_customer_profile_new($profile_type, $order->uid);
    }
    
    // Add the order context to the profile to ensure it can be updated without
    // resulting in customer profile duplication.
    $profile->entity_context = array(
        'entity_type' => 'commerce_order',
        'entity_id' => $order->order_id,
    );
    
    // Prepare an addressfield array to set to the customer profile.
    $field = field_info_field('commerce_customer_address');
    $instance = field_info_instance('commerce_customer_profile', 'commerce_customer_address', $profile->type);
    $address = addressfield_default_values($field, $instance);
    
    // Use the first name and last name if the profile is a billing profile.
    //if ($profile_type == 'billing')
    //{
        $address['first_name'] = $response['FIRSTNAME'];
        $address['last_name'] = $response['LASTNAME'];
        $address['name_line'] = $address['first_name'] . ' ' . $address['last_name'];
    //}
    //elseif ($profile_type == 'shipping')
    //{
        // Otherwise if it's a shipping profile, populate the address with all of
        // the shipping information returned from PayPAl.
    
        // Map addressfield value keys to keys available in the response array.
        $key_map = array(
        'country' => 'SHIPTOCOUNTRYCODE',
        'name_line' => 'SHIPTONAME',
        'first_name' => NULL,
        'last_name' => NULL,
        'organisation_name' => NULL,
        'administrative_area' => 'SHIPTOSTATE',
        'sub_administrative_area' => NULL,
        'locality' => 'SHIPTOCITY',
        'dependent_locality' => NULL,
        'postal_code' => 'SHIPTOZIP',
        'thoroughfare' => 'SHIPTOSTREET',
        'premise' => 'SHIPTOSTREET2',
        'sub_premise' => NULL,
        'data' => NULL,
        );
    
        // Loop over the addressfield value array looking for values in the response
        // array that match parts of the address to update.
        foreach ($address as $key => &$value)
        {
            // If there is no correlation for the current field key, skip it.
            if (empty($key_map[$key]))
            {
                continue;
            }
        
            // Update the addressfield value array with the value from the response
            // array. Note that we will erase existing data if it isn't present in the
            // response array.
            $response_key = $prefix . $key_map[$key];
        
            if (empty($response[$response_key]))
            {
                $value = '';
            }
            else
            {
                $value = $response[$response_key];
            }
        }
    //}
    
    // Add the addressfield value to the customer profile.
    $profile_wrapper = entity_metadata_wrapper('commerce_customer_profile', $profile);
    $profile_wrapper->commerce_customer_address = $address;
    
    // Save the customer profile and update the order to reference it.
    $profile_wrapper->save();
    $order_wrapper->{'commerce_customer_' . $profile_type} = $profile_wrapper;
    
    // Save the order if specified.
    if (!$skip_save)
    {
        $order_wrapper->save();
    }
}

/**
 * Returns a name-value pair array of information to the API request.
 *
 * @param object $order
 *   The order to itemized
 * @param string $currency_code
 *   The currency to return the different amounts.
 *
 * @return array
 *   A name-value pair array.
 */
function commerce_paypal_adaptive_itemize_order($order, $receiver)
{
    $nvp = array();
    
    // Extract the order total value array.
    $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
    $order_total = $order_wrapper->commerce_order_total->value();
    $currency_code = $order_total['currency_code'];
    //dpm($order_total);
    
    // Initialize the order level amount parameter.
    $amt = $order_total['amount'];
    
    // Loop over all the line items on the order to determine the total item
    // amount and shipping amount.
    $i = 0;
    
    $shippingamt = 0;
    
    foreach ($order_wrapper->commerce_line_items as $delta => $line_item_wrapper)
    {
        // If the current line item is a shipping line item, track its amount value
        // without taxes separately from products.
        if (module_exists('commerce_shipping') && $line_item_wrapper->type->value() == 'shipping')
        {
            // Extract the unit price.
            $shipping_price = $line_item_wrapper->commerce_unit_price->value();
        
            // Track the total costs of all shipping line items on the order to add to
            // the final payment request as a single amount, though typically this
            // should be limited to one shipping line item per order.
            $shippingamt += $shipping_price['amount'];
        }
        else
        {
            // Extract the line item unit price value array.
            $unit_price = $line_item_wrapper->commerce_unit_price->value();
    
            // Convert the unit price to the propery currency.
            $l_amt = commerce_currency_convert($unit_price['amount'], $unit_price['currency_code'], $currency_code);
    
            // Add payment details line items.
            $nvp += array(
                'L_PAYMENTREQUEST_0_NAME' . $i => commerce_line_item_title($line_item_wrapper->value()),
                'L_PAYMENTREQUEST_0_AMT' . $i => commerce_paypal_price_amount($l_amt, $currency_code),
                'L_PAYMENTREQUEST_0_QTY' . $i => round($line_item_wrapper->quantity->value()),
            );
    
            // If it was a product line item, add the SKU.
            if (in_array($line_item_wrapper->type->value(), commerce_product_line_item_types()))
            {
                $nvp['L_PAYMENTREQUEST_0_NUMBER' . $i] = $line_item_wrapper->line_item_label->value();
            }
            else
            {
                // Otherwise add the label as the description.
                $nvp['L_PAYMENTREQUEST_0_NUMBER' . $i] = $line_item_wrapper->line_item_label->value();
            }
    
            $i++;
        }
    }
    //Add PayPal transaction fees to invoice
    $invoice_amount = commerce_paypal_price_amount($amt, $currency_code);
    $feeAmount = (float)$receiver['amount'] - (float)$invoice_amount;
    if ($feeAmount > 0)
    {
        $nvp += array(
                'L_PAYMENTREQUEST_0_NAME' . $i => t('PayPal Transaction Fee'),
                'L_PAYMENTREQUEST_0_AMT' . $i => $feeAmount,
                'L_PAYMENTREQUEST_0_QTY' . $i => 1,
                'L_PAYMENTREQUEST_0_NUMBER' . $i => 'payfee'
            );
    }
    
    // Determine the order level item amount and tax amount line items. To prevent
    // rounding problems getting in the way, we calculate them based on the order
    // total instead of tallying it from each line item.
    if (module_exists('commerce_tax'))
    {
        $taxamt = commerce_round(COMMERCE_ROUND_HALF_UP, commerce_tax_total_amount($order_total['data']['components'], FALSE, $currency_code)); //todo: look into why this doesn't work properly
    }
    else
    {
        $taxamt = 0;
    }
    
    // Add the total item and tax amounts to the payment request
    $nvp += array(
        'PAYMENTREQUEST_0_ITEMAMT' => commerce_paypal_price_amount($amt - $taxamt - $shippingamt, $currency_code) + $feeAmount, //get around weird PayPal quirk
        'PAYMENTREQUEST_0_TAXAMT' => commerce_paypal_price_amount($taxamt, $currency_code),
    );
    
    if ($shippingamt > 0)
    {
        $nvp['PAYMENTREQUEST_0_SHIPPINGAMT'] = commerce_paypal_price_amount($shippingamt, $currency_code);
    }
    
    return $nvp;
}

/**
 * Returns an array of all possible currency codes for the PayPal Adaptive
 * payment method.
 *
 * @return
 *   An associative array of currency codes with keys and values being the
 *   currency codes accepted by the PayPal Adaptive payment method.
 */
function commerce_paypal_adaptive_currencies() {
  return drupal_map_assoc(array('AUD', 'BRL', 'CAD', 'CHF', 'CZK', 'DKK', 'EUR', 'GBP', 'HKD', 'HUF', 'ILS', 'JPY', 'MXN', 'MYR', 'NOK', 'NZD', 'PHP', 'PLN', 'SEK', 'SGD', 'THB', 'TRY', 'TWD', 'USD'));
}

/**
 * Implements hook_views_api().
 */
function commerce_paypal_adaptive_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'commerce_paypal_adaptive') . '/includes/views',
  );
}
